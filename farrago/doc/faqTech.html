<html>
<!--
  -->

<head>
<title>Farrago Developer FAQ</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css" />
<style>
<!--
.small { font-family: verdana,arial,helvetica,sans-serif; font-size: x-small; }
-->
</style>
</head>

<body>
<h1>Farrago Developer FAQ</h1>

<h2>How do I get a Java stack trace?</h2> 

Some front-end tools allow you to see Java stack traces directly.  For
example, in sqlline, if you issue the <code>!set verbose on</code>
command, a stack trace is reported with every subsequent error.

<p>

For other cases, you can often make use of the fact that all
exceptions propagated through the Farrago JDBC driver are traced.  In
file <code>dev/farrago/trace/FarragoTrace.properties</code>, set
<code>net.sf.farrago.jdbc.level=FINER</code>, then do whatever causes
the exception and look at the tail of file 
<code>dev/farrago/trace/FarragoTrace.log</code>.

<hr>

<h2>How do I get a Fennel C++ stack trace?  How do I debug Fennel?</h2> 

At the moment, there's no nice automated stack trace like in Java (besides
a standard core dump).  However, it is possible to use gdb to debug
Fennel.  Before starting the Java virtual machine, set environment
variable <code>JNI_DEBUG=1</code> in the shell from which you are
going to run Java.  When the Fennel JNI layer is loaded, you should see
a message like "Waiting for debugger; pid=18454".  Start gdb and tell it
to attach to the process with the given pid.  The process should be
sleeping in method <code>JNI_OnLoad</code>; set whatever breakpoints
you want and then issue the gdb continue command.

<hr>

<h2>How do I deal with bad Java code generated by the optimizer?</h2> 

The first thing to do when you an encounter an internal error
resulting from such a bug is to make sure you can see the code in
question.  In file <code>FarragoTrace.properties</code>, set
<code>net.sf.farrago.dynamic.level=FINE</code> before executing the
SQL statement.  This will guarantee that the generated .java file will
be preserved under directory
dev/farrago/classes/net/sf/farrago/dynamic/stmtXYZ (where XYZ is a random
unique suffix which you may be able to see in the error message).  If
the problem is that the generated code isn't even legal Java, it may
be very difficult to find what's going wrong if DynamicJava is being
used to interpret the generated code directly.  In that case, set
trace <code>net.sf.farrago.compiler.level=FINE</code>, which will
result in Sun's java compiler being used instead.  This usually gives
a good compilation error which you can use together with the generated
source code to find the problem (at this point, someone still has to
debug the code generator to track down the origin of the problem and
fix it).  Turn off both traces when you're done since the dynamic
trace clutters up disk space, and forcing compilation isn't always
good for performance.

<p>

If the generated Java code runs but does the wrong thing, you may have
to debug it if you can't find the problem by inspection.  To do this,
make sure the compiler trace is set before starting, since you really
don't want to debug DynamicJava.  Now, set a breakpoint in the finally
clause of method
<code>net.sf.farrago.db.FarragoDatabase.prepareStmt</code> and execute
the SQL statement.  Once this breakpoint is reached, the dynamically
compiled class should already be loaded.  Now, find the place in your
debugger where you can browse loaded classes (assuming there is one)
and navigate to package <code>net.sf.farrago.dynamic</code>.  If
there's only one class listed under there, that's it.  Otherwise, you
can use the field <code>packageName</code> from the local variable
<code>stmt</code> in the <code>prepareStmt()</code> method to find
your class in the haystack.  Now, set breakpoints in the generated
class and off you go.

<hr>

<h2>Why do my trace setting changes sometimes take effect immediately,
but other times they're ignored until the next virtual machine
invocation?</h2>

The trace system has a thread which polls file
<code>FarragoTrace.properties</code> every second for changes.  When
changes are detected, the file is reloaded and the new settings are traced
to <code>FarragoTrace.log</code>.  This can be very useful in
the middle of a debugging session.

<p>

However, some subsystems (Fennel in particular) cache trace settings
for performance.  Cached trace settings are typically associated with
an object lifetime.  For example, when a TupleStream graph is first
prepared, extra trace streams are instrumented into the graph if the
corresponding trace setting is set.  These continue to trace for the
lifetime of the graph.  Conversely, if the graph was prepared when
trace was off, no extra streams are created, and the graph's execution
will never be traced even if the trace settings change in the middle.
This is intentional, but when combined with object caching, it can
make debugging mysterious.  If you want to be sure of getting
something traced, start a new VM after changing trace settings. 

<hr>

<h2>Why do some breakpoints get skipped entirely, even though they
must have been hit in order for a statement to execute?</h2>

Farrago employs a fairly advanced cache strategy for objects used in
the implementation of SQL statements.  This means that after the first
preparation request, subsequent preparation requests will be able to
use the cached implementation, skipping most of preparation (and your
breakpoints) entirely.  As usual, this is good for performance but
makes debugging more difficult.  You can minimize implementation
caching by executing the SQL statement <code>alter system set
"codeCacheMaxBytes"=0</code>.  When done, use <code>alter system set
"codeCacheMaxBytes"=-1</code> to remove the limit (otherwise normal
operation will be much slower).

<hr>

</body>
</html>
