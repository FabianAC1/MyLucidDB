
<html>

<head>
<title>Farrago Framework Architecture</title>
<link rel="stylesheet" type="text/css" href="../stylesheet.css" />
</head>

<body>

<h1>Farrago Framework Architecture</h1> 

<h2>Overview</h2>

The Farrago architecture defines a pluggable framework with the goal
of extensibility in a variety of directions.  Not all of this
framework is in place yet; this document describes a proposal for how
it will look when it is complete.  Fine-grained details of the
interfaces involved are not covered; the scope of explanation is the
system as a whole. The diagram below provides the big picture:

<hr>
<img src="PluginArchitecture.gif">
<hr>

The framework spans a number of programming, scripting, and modeling languages:

<ul>

<li>UML is used for defining all metadata models and driving the
model-driven code generation build process.  Farrago uses the standard
<a href="http://www.omg.org/cwm">CWM</a> metamodel from <a
href="http://www.omg.org">OMG</a> as a base, and defines its own
extension model (FEM) as well.  Projects which want to customize the
Farrago metadata can define their own model extensions.  All
definitions which are shared across multiple programming languages are
defined in UML.

<li>C++ is used in the server framework for components in which a
native code implementation is required for performance, API access, or
low-level system access.  The C++ portion of the framework (known as
Fennel, which is also an independent project) is not directly
pluggable.  Instead, extension C++ modules can be defined together
with wrapper Java plugins as companions (interfacing via JNI).  In
this document, the term <em>module</em> is used to describe a
component which is designed to fit into predefined interfaces, while
the term <em>plugin</em> is reserved for modules which can be
dynamically installed into a running server via DDL commands.  The C++
portion of the framework is optional; it is possible to build a
pure-Java DBMS by extending the Farrago framework, although not all of
the necessary components are currently provided.

<li>Java is the preferred environment for extensibility in the server
framework since as a managed code environment it is much safer than
C++ and provides access to a large number of important API's.  Java
plugins may be pure-Java, or may include C++ components called via JNI.

<li>Beyond plugins defining the server's behavior, another layer of
extensibility exists in support for stored procedures and SQL scripts.

<li>Finally, access to the server from as many client environments as
possible is another important direction for extensibility.

</ul>

<h2>Build Configuration</h2>

With a pluggable architecture, figuring out what needs to be built and
how in order to create a useful specialized distribution can be a
major headache.  Our plan is to follow the Linux kernel
configuration process at an abstract level, though of course the
details are different:

<hr>
<img src="BuildConfiguration.gif">
<hr>

<ul>

<li>Development organizations such as The Eigenbase Project will
maintain a master list of all contributed components, together with
their dependencies and licensing requirements.  This list will be
included in all downloaded source distributions.

<li>Projects wishing to incorporate additional non-contributed
components can maintain their own private lists as well.

<li>The configuration process takes the union of the above lists as
input, together with project-specific directives for which components
to include and how they should be packaged.  An interactive tool will
be supplied for specifying these directives

<li>TODO:  add a dependency validation step to the digram

<li>As its primary output, the configuration procedure produces a
number of build scripts (whose steps are outlined in the rest of this
document.

<li>In addition, the configuration procedure produces a description of
the licenses required in order to distribute the result of the build.
For example, these requirements might state "This system may be
distributed under the GNU GPL or under a commercial license from
Companies X and Y".

</ul>

NOTE: in the diagram above and in those which follow, the meaning of
the pseudo-flowchart symbols is as follows:

<hr>
<img src="BuildLegend.gif">
<hr>

<h2>Assembly Line</h2>

Once the top-level build scripts are defined for a particular
distribution, the procedure for building the various core and
extension components is as follows:

<hr>
<img src="AssemblyLine.gif">
<hr>

The result of this assembly line is a number of individual modules
which have not yet been packaged into a redistributable form, plus an
uninitialized catalog database.  Further steps depend on the nature of
the distribution to be produced (as covered in the next two sections).

<h2>System Packaging</h2>

One option is to package a distribution for an entire working system,
as follows:

<hr>
<img src="SystemPackaging.gif">
<hr>

After plugin jars are built, the <em>Initialization</em> process
performs enough bootstrapping to be able to load all required
components and run site-independent initialization scripts.  The
result is an initialized site-independent catalog database; this must
be included in the final packaging together with the executable
components, and serves as a base for site-dependent initialization
when a distribution is deployed.  Of course, other resources such as
documentation should be included in the final packaging, but are not
shown here.

<h2>Plugin Packaging</h2>

The other distribution option is to package only individual plugins,
with the intention that they be used together with some other full
system distributions.  In this case, it is a requirement that such
plugins consist of only code, without model extensions, although the
plugins are allowed to depend on model extensions provided with
specific system distributions.  The plugin-only packaging process is
much simpler:

<hr>
<img src="PluginPackaging.gif">
<hr>

The diagram above illustrates the most general case of both Java and
C++ code being required to implement the plugin.

</ul>

</body>

</html>

