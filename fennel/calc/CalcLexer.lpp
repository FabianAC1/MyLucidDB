%option noyywrap
%option c++
%option yylineno
%option prefix="CalcYY"
%option outfile="lex.yy.c"
%option yyclass="CalcLexer"

%{
#include "fennel/common/CommonPreamble.h"
#define  DONOT_INCLUDE_FLEX_HEADER
#include "fennel/calc/CalcLexer.h"
#include "fennel/calc/CalcGrammar.h"
#include "fennel/calc/CalcAssemblerException.h"

/* need this for checking results of strtoull, strtoll, strtod */
#include <errno.h>

#define YY_USER_ACTION updateLocation();

using namespace fennel;

/*FENNEL_BEGIN_CPPFILE("$Id") */
%}

DIGIT       [0-9]
HEX         [A-Za-z0-9]
%s          expect_hex

%%

","         return COMMA;
";"         return TERM;
"T"         return CODE_START;
"@"         return AT;

"L"         { yylval.u.v_regset = RegisterReference::ELocal;   return REG_LOCAL;   }
"S"         { yylval.u.v_regset = RegisterReference::EStatus;  return REG_STATUS;  }
"I"         { yylval.u.v_regset = RegisterReference::EInput;   return REG_INPUT;   }
"O"         { yylval.u.v_regset = RegisterReference::EOutput;  return REG_OUTPUT;  }
"C"         { yylval.u.v_regset = RegisterReference::ELiteral; return REG_LITERAL; }
"V"         { return VALUES; }

"s1"        { yylval.u.v_type = STANDARD_TYPE_INT_8;      return TYPE_FIXED; }
"u1"        { yylval.u.v_type = STANDARD_TYPE_UINT_8;     return TYPE_FIXED; }
"s2"        { yylval.u.v_type = STANDARD_TYPE_INT_16;     return TYPE_FIXED; }
"u2"        { yylval.u.v_type = STANDARD_TYPE_UINT_16;    return TYPE_FIXED; }
"s4"        { yylval.u.v_type = STANDARD_TYPE_INT_32;     return TYPE_FIXED; }
"u4"        { yylval.u.v_type = STANDARD_TYPE_UINT_32;    return TYPE_FIXED; }
"s8"        { yylval.u.v_type = STANDARD_TYPE_INT_64;     return TYPE_FIXED; }
"u8"        { yylval.u.v_type = STANDARD_TYPE_UINT_64;    return TYPE_FIXED; }
"bo"        { yylval.u.v_type = STANDARD_TYPE_BOOL;       return TYPE_FIXED; }
"r"         { yylval.u.v_type = STANDARD_TYPE_REAL;       return TYPE_FIXED; }
"d"         { yylval.u.v_type = STANDARD_TYPE_DOUBLE;     return TYPE_FIXED; }
"c"         { yylval.u.v_type = STANDARD_TYPE_CHAR;       return TYPE_VARIABLE; }
"vc"        { yylval.u.v_type = STANDARD_TYPE_VARCHAR;    return TYPE_VARIABLE; }
"b"         { yylval.u.v_type = STANDARD_TYPE_BINARY;     return TYPE_VARIABLE; }
"vb"        { yylval.u.v_type = STANDARD_TYPE_VARBINARY;  return TYPE_VARIABLE; }

[A-Z]+      { yylval.v_opcode = yytext; return OPCODE; }

"0x"        BEGIN(expect_hex);
<expect_hex>{HEX}+ { 
                     yylval.v_string = hex2string(yytext, yyleng); 
                     BEGIN(INITIAL); 
                     return STRING; 
                   }

{DIGIT}+    {
                errno = 0;
                yylval.u.v_uint64 = strtoull(yytext, NULL, 10);
                if (errno != 0)
                    LexerError(strerror(errno));
                return UNSIGNED_INTEGER;
            }

-{DIGIT}+   {
                errno = 0;
                yylval.u.v_int64 = strtoll(yytext, NULL, 10);
                if (errno != 0)
                    LexerError(strerror(errno));
                return NEGATIVE_INTEGER;
            }

-?{DIGIT}+"."{DIGIT}*    {
                errno = 0;
                yylval.u.v_double = strtod(yytext, NULL);
                if (errno != 0)
                    LexerError(strerror(errno));
                return REAL;
            }

[ \t\r]+    /* eat up whitespace */
[\n]+       {
               /* eat up new lines.  Reset column to 1. */
               yycolno=1;
            }

.           return UNKNOWN_TOKEN;

%%

void CalcLexer::updateLocation()
{   
    /* We don't need to update yylineno since flex takes care of that automatically
     * This function does not handle tokens that span multiple lines.
     */
    yyloc.first_line   = yylineno;
    yyloc.first_column = yycolno;
    yyloc.first_pos    = yypos;
    yycolno += yyleng;
    yypos += yyleng;
    yyloc.last_line   = yylineno;
    yyloc.last_column = yycolno-1;
    yyloc.last_pos    = yypos-1;
}

void CalcLexer::LexerError(const char* msg)
{     
    throw CalcAssemblerException(msg, getLocation()); 
}

int CalcLexer::hex(char ch)
{
  if ((ch >= 'a') && (ch <= 'f')) return (ch-'a'+10);
  else if ((ch >= '0') && (ch <= '9')) return (ch-'0');
  else if ((ch >= 'A') && (ch <= 'F')) return (ch-'A'+10);
  else throw CalcAssemblerException("Invalid hex character", getLocation());  
}

/* convert the hex array pointed to by buf into binary string */
string CalcLexer::hex2string(const char *buf, uint buflen)
{   
    int i, count;
    unsigned char ch;

    assert(buf != NULL);
    if ((buflen % 2) != 0) {
        throw CalcAssemblerException("Invalid hex encoded string", getLocation());
    }

    count = buflen/2;

    string str(count, 0);

    for (i=0; i<count; i++) {
        ch = hex(*buf++) << 4;
        ch = ch + hex(*buf++);
        str[i] = ch;
    }
    return str;
}

/*FENNEL_END_CPPFILE("$Id") */
