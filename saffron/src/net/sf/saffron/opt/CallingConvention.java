/*
// $Id$
// Saffron preprocessor and data engine
// (C) Copyright 2002-2003 Disruptive Technologies, Inc.
// (C) Copyright 2003-2004 John V. Sichi
// You must accept the terms in LICENSE.html to use this software.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public License
// as published by the Free Software Foundation; either version 2.1
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

package net.sf.saffron.opt;

import net.sf.saffron.rel.*;
import net.sf.saffron.util.EnumeratedValues;


/**
 * <code>CallingConvention</code> enumerates all calling conventions defined
 * by Saffron itself.  This set can be extended by applications by defining
 * new instances of CallingConvention and registering them with a planner,
 * along with the desired conversion rules.  Extended ordinals must be
 * greater than CallingConvention.enumeration.getMax().
 */
public class CallingConvention extends EnumeratedValues.BasicValue
{
    //~ Static fields/initializers --------------------------------------------

    /**
     * The <code>NONE</code> calling convention means that expression does not
     * support any calling convention -- in other words, it is not
     * implementable, and has to be transformed to something else in order to
     * be implemented.
     */
    public static final int NONE_ORDINAL = -1;
    public static final CallingConvention NONE =
        new CallingConvention("NONE",NONE_ORDINAL);

    /**
     * The <code>JAVA</code> calling convention means that the expression is
     * converted into an Openjava parse tree, which can then be un-parsed,
     * compiled, and executed as java code.
     * 
     * <p>
     * The {@link SaffronRel#implement} method generates a piece of code which
     * will call the piece of code corresponding to the parent once for each
     * row:
     * 
     * <ul>
     * <li>
     * The <dfn>parent code</dfn> is generated by calling {@link
     * RelImplementor#generateParentBody}, which in turn calls {@link
     * SaffronRel#implement}() on the parent.
     * </li>
     * <li>
     * The code is generated into the <dfn>current block</dfn> (gleaned from
     * {@link net.sf.saffron.opt.RelImplementor#getStatementList}).
     * </li>
     * </ul>
     * </p>
     */
    public static final int JAVA_ORDINAL = 0;
    public static final CallingConvention JAVA =
        new CallingConvention("JAVA",JAVA_ORDINAL);

    /**
     * The <code>ITERATOR</code> calling convention means that the expression
     * is converted to an openjava expression ({@link
     * openjava.ptree.Expression}) which evalutes to an {@link
     * java.util.Iterator}.  See {@link
     * net.sf.saffron.rel.convert.ConverterRel}.
     */
    public static final int ITERATOR_ORDINAL = 1;
    public static final CallingConvention ITERATOR =
        new CallingConvention("ITERATOR",ITERATOR_ORDINAL);

    /**
     * The <code>ARRAY</code> calling convention results in a Java expression
     * which evaluates to an array containing the rows returned.  Compare
     * with {@link #JAVA_ORDINAL}, where a loop <em>does something</em> for
     * each row returned).
     */
    public static final int ARRAY_ORDINAL = 2;
    public static final CallingConvention ARRAY =
        new CallingConvention("ARRAY",ARRAY_ORDINAL);

    /**
     * The <code>COLLECTION</code> calling convention results in a Java
     * expression which evaluates to a {@link java.util.Collection},
     * typically a {@link java.util.ArrayList}.
     */
    public static final int COLLECTION_ORDINAL = 3;
    public static final CallingConvention COLLECTION =
        new CallingConvention("COLLECTION",COLLECTION_ORDINAL);
    public static final int VECTOR_ORDINAL = 4;
    public static final CallingConvention VECTOR =
        new CallingConvention("VECTOR",VECTOR_ORDINAL);
    public static final int ENUMERATION_ORDINAL = 5;
    public static final CallingConvention ENUMERATION =
        new CallingConvention("ENUMERATION",ENUMERATION_ORDINAL);
    public static final int MAP_ORDINAL = 6;
    public static final CallingConvention MAP =
        new CallingConvention("MAP",MAP_ORDINAL);
    public static final int HASHTABLE_ORDINAL = 7;
    public static final CallingConvention HASHTABLE =
        new CallingConvention("HASHTABLE",HASHTABLE_ORDINAL);

    /**
     * The <code>ITERABLE</code> calling convention means that the expression
     * is converted to an openjava expression ({@link
     * openjava.ptree.Expression}) which evalutes to an object which
     * implements {@link net.sf.saffron.runtime.Iterable}.
     */
    public static final int ITERABLE_ORDINAL = 8;
    public static final CallingConvention ITERABLE =
        new CallingConvention("ITERABLE",ITERABLE_ORDINAL);

    /**
     * The <code>EXISTS</code> calling convention is only allowed for a
     * terminator.
     */
    public static final int EXISTS_ORDINAL = 9;
    public static final CallingConvention EXISTS =
        new CallingConvention("EXISTS",EXISTS_ORDINAL);

    /**
     * The <code>RESULT_SET</code> calling convention means that the
     * expression is a {@link java.sql.ResultSet JDBC result set}. When a
     * result set is converted to another convention such as array or
     * iterator, the default object type is {@link net.sf.saffron.runtime.Row}.
     */
    public static final int RESULT_SET_ORDINAL = 10;
    public static final CallingConvention RESULT_SET =
        new CallingConvention("RESULT_SET",RESULT_SET_ORDINAL);

    public static final CallingConvention [] values =
        new CallingConvention [] {
            NONE,JAVA,ITERATOR,ARRAY,COLLECTION,VECTOR,ENUMERATION,MAP,
            HASHTABLE,ITERABLE,EXISTS,RESULT_SET,
        };
    public static final EnumeratedValues enumeration =
        new EnumeratedValues(values);

    //~ Constructors ----------------------------------------------------------

    public CallingConvention(String name,int ordinal)
    {
        super(name,ordinal,null);
    }
}


// End CallingConvention.java
